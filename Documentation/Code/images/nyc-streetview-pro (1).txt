#!/usr/bin/env python3
"""
NYC Street View Pro - Production-Ready Building Image Capture
=============================================================
Captures multiple Street View perspectives of NYC buildings using real street data,
proper Manhattan grid orientation, and intelligent camera positioning.

Features:
- Uses actual street bearings (Manhattan grid is ~29° rotated)
- Uses actual street widths from data
- Handles NaN values gracefully
- Progress tracking with resume capability
- Multiple image perspectives (far/near × directions/entrance)
- Proper even/odd address logic for camera positioning
- Optimized pitch/FOV calculations

Required packages:
pip install requests pandas pillow geopy numpy

CSV Required Columns:
- bbl: Building identifier
- address: Building address
"""

import requests
import math
import pandas as pd
import numpy as np
import re
import os
import sys
from PIL import Image
from io import BytesIO
import json
from datetime import datetime
import logging

# Configuration
# This is a dummy API key that will be automatically replaced by password manager
API_KEY = "AIzaSyCsPtot_LaeHITMOB7t9GANaukmNCBmHg0"  # Dummy key - auto-replaced by pw manager
DEFAULT_HEIGHT = 150  # Default building height in feet
DEFAULT_LENGTH = 100  # Default building length in feet
DEFAULT_STREET_WIDTH = 20  # Default street width in meters (standard NYC street)
DEFAULT_STREET_BEARING = 119  # Default bearing for E-W Manhattan streets
SAFETY_MARGIN = 0.85  # Use 85% of street width for camera offset

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('streetview_capture.log'),
        logging.StreamHandler(sys.stdout)
    ]
)

class StreetViewCapture:
    """Main class for capturing Street View images of buildings"""
    
    def __init__(self, csv_path, api_key=API_KEY):
        self.api_key = api_key
        self.csv_path = csv_path
        self.script_dir = os.path.dirname(os.path.abspath(__file__))
        self.completed_file = os.path.join(self.script_dir, 'completed_buildings.txt')
        self.completed_buildings = self.load_completed_buildings()
        self.stats = {'processed': 0, 'skipped': 0, 'failed': 0, 'images_saved': 0}
        
    def load_completed_buildings(self):
        """Load list of completed buildings for resume capability"""
        if os.path.exists(self.completed_file):
            with open(self.completed_file, 'r') as f:
                completed = set(line.strip() for line in f)
            logging.info(f"Resuming: Found {len(completed)} previously completed buildings")
            return completed
        return set()
    
    def mark_completed(self, folder_name):
        """Mark a building as completed"""
        with open(self.completed_file, 'a') as f:
            f.write(folder_name + '\n')
        self.completed_buildings.add(folder_name)
        
    def sanitize_filename(self, text):
        """Convert address to valid filename"""
        return re.sub(r'[^a-zA-Z0-9]', '_', text)
    
    def geocode_address(self, address):
        """Geocode address to coordinates using Google Geocoding API"""
        url = (
            f"https://maps.googleapis.com/maps/api/geocode/json?"
            f"address={requests.utils.quote(address)}&key={self.api_key}"
        )
        
        try:
            response = requests.get(url, timeout=10).json()
            if response['status'] == 'OK' and response['results']:
                location = response['results'][0]['geometry']['location']
                return location['lat'], location['lng']
        except Exception as e:
            logging.error(f"Geocoding error for {address}: {e}")
        
        return None, None
    
    def get_entrance_coordinates(self, address):
        """Get building entrance using Geocoding API v3 with extra_computations"""
        url = (
            f"https://maps.googleapis.com/maps/api/geocode/json?"
            f"address={requests.utils.quote(address)}"
            f"&extra_computations=BUILDING_AND_ENTRANCES"
            f"&key={self.api_key}"
        )
        
        try:
            response = requests.get(url, timeout=10).json()
            if response['status'] == 'OK' and response['results']:
                result = response['results'][0]
                
                if 'building_and_entrances' in result:
                    entrances = result['building_and_entrances'].get('entrances', [])
                    
                    # Look for PREFERRED entrance
                    for entrance in entrances:
                        if 'PREFERRED' in entrance.get('entrance_tags', []):
                            location = entrance.get('location', {})
                            lat = location.get('lat')
                            lng = location.get('lng')
                            if lat and lng:
                                logging.info(f"Found PREFERRED entrance: {lat}, {lng}")
                                return lat, lng
                    
                    # If only one entrance, use it
                    if len(entrances) == 1:
                        location = entrances[0].get('location', {})
                        lat = location.get('lat')
                        lng = location.get('lng')
                        if lat and lng:
                            logging.info(f"Using single entrance as preferred: {lat}, {lng}")
                            return lat, lng
        except Exception as e:
            logging.error(f"Entrance API error for {address}: {e}")
        
        return None, None
    
    def get_street_position(self, lat, lng, address):
        """Get street-level position using Directions API"""
        url = (
            f"https://maps.googleapis.com/maps/api/directions/json?"
            f"origin={lat},{lng}&destination={lat},{lng}&mode=walking"
            f"&key={self.api_key}"
        )
        
        try:
            response = requests.get(url, timeout=10).json()
            if response['status'] == 'OK' and response['routes']:
                route = response['routes'][0]
                if route['legs'] and route['legs'][0]['steps']:
                    end_location = route['legs'][0]['end_location']
                    return end_location['lat'], end_location['lng']
        except Exception as e:
            logging.error(f"Directions API error: {e}")
        
        return lat, lng  # Fallback to original
    
    def is_even_address(self, address):
        """Check if building number is even or odd"""
        match = re.search(r'\b(\d+)', address)
        if match:
            return int(match.group(1)) % 2 == 0
        return None
    
    def offset_coords(self, lat, lng, distance_meters, bearing_degrees):
        """Calculate offset coordinates given distance and bearing"""
        R = 6371000  # Earth's radius in meters
        
        lat_rad = math.radians(lat)
        bearing_rad = math.radians(bearing_degrees)
        
        lat2_rad = math.asin(
            math.sin(lat_rad) * math.cos(distance_meters / R) +
            math.cos(lat_rad) * math.sin(distance_meters / R) * math.cos(bearing_rad)
        )
        
        lng2_rad = math.radians(lng) + math.atan2(
            math.sin(bearing_rad) * math.sin(distance_meters / R) * math.cos(lat_rad),
            math.cos(distance_meters / R) - math.sin(lat_rad) * math.sin(lat2_rad)
        )
        
        return math.degrees(lat2_rad), math.degrees(lng2_rad)
    
    def get_camera_position(self, lat, lng, address, street_bearing, street_width):
        """Calculate camera position based on even/odd logic and street data"""
        is_even = self.is_even_address(address)
        
        # Manhattan even/odd logic:
        # Even addresses: Camera goes to opposite (north/west) side
        # Odd addresses: Camera goes to opposite (south/east) side
        if is_even:
            camera_bearing = (street_bearing - 90) % 360  # SUBTRACT for even
        else:
            camera_bearing = (street_bearing + 90) % 360  # ADD for odd
        
        distance = street_width * SAFETY_MARGIN
        
        camera_lat, camera_lng = self.offset_coords(lat, lng, distance, camera_bearing)
        
        logging.info(f"Camera position: Even={is_even}, Bearing={camera_bearing}°, Distance={distance:.1f}m")
        
        return camera_lat, camera_lng
    
    def calculate_heading(self, camera_lat, camera_lng, target_lat, target_lng):
        """Calculate compass heading from camera to target"""
        # Using "backwards" atan2 to convert to compass bearings
        angle_rad = math.atan2(target_lng - camera_lng, target_lat - camera_lat)
        heading = (math.degrees(angle_rad) + 360) % 360
        return heading
    
    def calculate_pitch(self, building_height_ft, distance_meters):
        """Calculate optimal pitch angle"""
        distance_ft = distance_meters * 3.28084
        camera_height_ft = 8  # Street View camera height
        
        effective_height = max(0, building_height_ft - camera_height_ft)
        pitch_rad = math.atan(effective_height / distance_ft)
        pitch_deg = math.degrees(pitch_rad)
        
        # Apply dampening for extreme angles
        if pitch_deg > 40:
            pitch_deg = 40 + (pitch_deg - 40) * 0.5
        elif pitch_deg > 30:
            pitch_deg = 30 + (pitch_deg - 30) * 0.7
        
        # Apply reductions for better framing
        pitch_deg = pitch_deg * 0.85 * 0.75 * 0.7
        
        return round(max(10, min(pitch_deg, 65)), 1)
    
    def calculate_fov(self, building_length_ft, distance_meters):
        """Calculate optimal field of view"""
        distance_ft = distance_meters * 3.28084
        half_width = building_length_ft / 2
        fov_rad = 2 * math.atan(half_width / distance_ft)
        fov_deg = math.degrees(fov_rad) * 1.2  # 20% margin
        
        return round(max(65, min(fov_deg, 110)))
    
    def get_streetview_image(self, lat, lng, heading, fov, pitch):
        """Fetch Street View image from Google API"""
        quality_levels = [
            {"size": "2048x2048", "name": "Ultra HD"},
            {"size": "1024x1024", "name": "High"},
            {"size": "640x640", "name": "Standard"}
        ]
        
        for quality in quality_levels:
            url = (
                f"https://maps.googleapis.com/maps/api/streetview?"
                f"size={quality['size']}&location={lat},{lng}"
                f"&heading={heading}&fov={fov}&pitch={pitch}"
                f"&source=outdoor&radius=50&return_error_code=true"
                f"&key={self.api_key}"
            )
            
            try:
                response = requests.get(url, timeout=15)
                if response.status_code == 200 and response.content:
                    image = Image.open(BytesIO(response.content))
                    if image.size[0] > 100:  # Valid image check
                        logging.info(f"Image quality: {quality['name']}")
                        return image
            except Exception as e:
                logging.warning(f"Failed at {quality['name']} quality: {e}")
        
        return None
    
    def process_building(self, building):
        """Process a single building and capture all images"""
        address = building['address']
        bbl = building.get('bbl', 'N/A')
        folder_name = self.sanitize_filename(address)
        
        # Skip if already processed
        if folder_name in self.completed_buildings:
            logging.info(f"Skipping (already done): {address}")
            self.stats['skipped'] += 1
            return
        
        logging.info(f"\nProcessing: {address} (BBL: {bbl})")
        
        # Use default values for all building parameters
        height = DEFAULT_HEIGHT
        building_length = DEFAULT_LENGTH
        street_width = DEFAULT_STREET_WIDTH
        
        # Determine street bearing based on address pattern
        # Avenues run N-S (~29° in Manhattan), Streets run E-W (~119°)
        address_lower = address.lower()
        if any(x in address_lower for x in ['avenue', 'ave', 'broadway']):
            street_bearing = 29  # N-S avenue bearing
        else:
            street_bearing = DEFAULT_STREET_BEARING  # E-W street bearing
        
        logging.info(f"Using defaults: Height={height}ft, Length={building_length}ft, "
                     f"Width={street_width}m, Bearing={street_bearing}°")
        
        # Geocode address
        building_lat, building_lng = self.geocode_address(address)
        if building_lat is None or building_lng is None:
            logging.error(f"Geocoding failed for {address}")
            self.stats['failed'] += 1
            return
        
        # Get street-level position
        street_lat, street_lng = self.get_street_position(building_lat, building_lng, address)
        
        # Create output folder
        address_folder = os.path.join(self.script_dir, folder_name)
        os.makedirs(address_folder, exist_ok=True)
        
        images_captured = []
        
        # Capture far (offset) image from Directions API position
        try:
            camera_lat, camera_lng = self.get_camera_position(
                street_lat, street_lng, address, street_bearing, street_width
            )
            heading = self.calculate_heading(camera_lat, camera_lng, building_lat, building_lng)
            pitch = self.calculate_pitch(height, street_width * SAFETY_MARGIN)
            fov = self.calculate_fov(building_length, street_width * SAFETY_MARGIN)
            
            image = self.get_streetview_image(camera_lat, camera_lng, heading, fov, pitch)
            if image:
                filename = os.path.join(address_folder, f"{folder_name}_far_directions.png")
                image.save(filename)
                images_captured.append("far_directions")
                self.stats['images_saved'] += 1
        except Exception as e:
            logging.error(f"Error capturing far image: {e}")
        
        # Capture near (entrance) image from Directions API position
        try:
            heading = self.calculate_heading(street_lat, street_lng, building_lat, building_lng)
            pitch = min(65, pitch * 1.5)  # Increase pitch for closer view
            fov = min(110, fov * 1.3)  # Wider FOV for closer view
            
            image = self.get_streetview_image(street_lat, street_lng, heading, fov, pitch)
            if image:
                filename = os.path.join(address_folder, f"{folder_name}_near_directions.png")
                image.save(filename)
                images_captured.append("near_directions")
                self.stats['images_saved'] += 1
        except Exception as e:
            logging.error(f"Error capturing near image: {e}")
        
        # Try to get entrance coordinates and capture entrance images
        entrance_lat, entrance_lng = self.get_entrance_coordinates(address)
        if entrance_lat and entrance_lng:
            # Far entrance image
            try:
                camera_lat, camera_lng = self.get_camera_position(
                    entrance_lat, entrance_lng, address, street_bearing, street_width
                )
                heading = self.calculate_heading(camera_lat, camera_lng, building_lat, building_lng)
                pitch = self.calculate_pitch(height, street_width * SAFETY_MARGIN)
                fov = self.calculate_fov(building_length, street_width * SAFETY_MARGIN)
                
                image = self.get_streetview_image(camera_lat, camera_lng, heading, fov, pitch)
                if image:
                    filename = os.path.join(address_folder, f"{folder_name}_far_entrance.png")
                    image.save(filename)
                    images_captured.append("far_entrance")
                    self.stats['images_saved'] += 1
            except Exception as e:
                logging.error(f"Error capturing far entrance image: {e}")
            
            # Near entrance image
            try:
                heading = self.calculate_heading(entrance_lat, entrance_lng, building_lat, building_lng)
                pitch = min(65, pitch * 1.5)
                fov = min(110, fov * 1.3)
                
                image = self.get_streetview_image(entrance_lat, entrance_lng, heading, fov, pitch)
                if image:
                    filename = os.path.join(address_folder, f"{folder_name}_near_entrance.png")
                    image.save(filename)
                    images_captured.append("near_entrance")
                    self.stats['images_saved'] += 1
            except Exception as e:
                logging.error(f"Error capturing near entrance image: {e}")
        
        # Mark as completed if we got any images
        if images_captured:
            self.mark_completed(folder_name)
            self.stats['processed'] += 1
            logging.info(f"✓ Completed {address} with {len(images_captured)} images")
        else:
            self.stats['failed'] += 1
            logging.error(f"✗ Failed to capture any images for {address}")
    
    def run(self):
        """Process all buildings in the CSV"""
        # Load and validate CSV
        try:
            df = pd.read_csv(self.csv_path)
            logging.info(f"Loaded {len(df)} buildings from {self.csv_path}")
        except Exception as e:
            logging.error(f"Failed to load CSV: {e}")
            return
        
        # Process each building
        start_time = datetime.now()
        
        for idx, building in df.iterrows():
            try:
                self.process_building(building)
            except Exception as e:
                logging.error(f"Unexpected error processing {building.get('address', 'unknown')}: {e}")
                self.stats['failed'] += 1
        
        # Final statistics
        elapsed = datetime.now() - start_time
        logging.info("\n" + "="*50)
        logging.info("PROCESSING COMPLETE")
        logging.info(f"Total time: {elapsed}")
        logging.info(f"Buildings processed: {self.stats['processed']}")
        logging.info(f"Buildings skipped: {self.stats['skipped']}")
        logging.info(f"Buildings failed: {self.stats['failed']}")
        logging.info(f"Total images saved: {self.stats['images_saved']}")
        logging.info(f"Average images per building: {self.stats['images_saved'] / max(self.stats['processed'], 1):.1f}")
        

def main():
    """Main entry point"""
    import argparse
    
    parser = argparse.ArgumentParser(description='NYC Street View Pro - Capture building images')
    parser.add_argument('--csv-file', default='/Users/forrestmiller/Desktop/buildings_addresses.csv',
                        help='Path to CSV file with building data')
    parser.add_argument('--api-key', default=API_KEY, help='Google Maps API key')
    parser.add_argument('--reset', action='store_true', help='Reset progress and start fresh')
    
    args = parser.parse_args()
    
    # Reset progress if requested
    if args.reset:
        completed_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'completed_buildings.txt')
        if os.path.exists(completed_file):
            os.remove(completed_file)
            print("Progress reset - starting fresh")
    
    # Run the capture
    capture = StreetViewCapture(args.csv_file, args.api_key)
    capture.run()


if __name__ == "__main__":
    main()
